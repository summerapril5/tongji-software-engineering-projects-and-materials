# 全书复习——专业抄书@onevfall

## 第1章

### 1.2 计算机系统结构的概念

#### 1.2.1 计算机系统的层次结构

1. 现代计算机是由 **硬件/固件** 和**软件**组成的十分复杂的系统。
2. 从**计算机语言**的角度出发，把计算机系统按**功能**划分成**多级层次结构**，每一层以一种语言为特征。
3. 计算机系统的**多级层次结构**如下：（基于计算机语言划分）
   - L6：应用语言虚拟机
   - L5：高级语言虚拟机
   - L4：汇编语言虚拟机
   - L3：操作系统虚拟机
   - L2：机器语言（传统机器级）
   - L1：微程序机器级
4. 计算机系统的多级层次结构具体的解释：
   1. 第一级是**微程序机器级**。这一级的机器语言是**微指令集**，其使用者是**计算机硬件设计人员**，他们用微指令编写的微程序直接由**固件/硬件**来*解释*实现。
   2. 第二级是**传统机器级**。这一级的机器语言就是**传统的机器指令集**，程序员用该指令集编写的程序由**L1的微程序**进行*解释*执行。
      - 由微程序解释指令集又称为**仿真**。实际上，在L1上可以有多个能够在其上运行的解释程序，每一个解释程序定义了一种指令集。因此，*可以通过仿真在一台计算机上实现多种指令集*。
      - 有的计算机没有采用微程序技术，因此没有微程序机器级。这时，L2的指令集是由**硬连逻辑**直接解释执行的。硬连逻辑的**优点**是***速度快**，**RISC处理器**由于指令集比较简单而经常采用这种方式实现*。
   3. 第三级是**操作系统虚拟机**。所谓**虚拟机**，是指由软件实现的机器，以区别于由固件/硬件实现的物理机器。这一级的机器语言由**传统机器级指令和操作系统级指令**构成。后者用于实现对操作系统功能的调用，如打开/关闭文件等。用这一级语言编写的程序是**由L3和L2来共同执行**的，其中只有**操作系统级指令是由操作系统进行*解释*执行**。
   4. 第四级是汇编语言虚拟机。这一级的机器语言是**汇编语言**。用汇编语言编写的程序首先*翻译*成L3和L2上的语言，然后再由相应的计算机执行。**完成这个*翻译***的程序称为**汇编程序**。
   5. 第5级是高级语言虚拟机。这一级的机器语言就是各种高级语言。用高级语言编写的程序一般由**编译器**翻译到**L4或L3**上，个别高级语言也用***解释***的方法实现。
   6. 第6级是应用语言虚拟机。用应用语言编写的程序一般是由**应用程序包** *翻译*到**L5**上。
5. 上述6级层次结构中，通常**L1-L3是用解释的**方法实现，而**L4-L6则是用翻译**的方法实现。
   - 相同点：都是以执行一串L(i)级指令来实现L(i+1)级指令
   - 不同点：
     - 翻译技术是把L(i+1)级程序**全部**转换成Li级程序，然后再去执行新产生的Li级程序，在执行过程中L(i+1)级程序不再被访问
     - 解释技术则是**每当一条**L(i+1)级指令被译码后，就直接去执行一串等效的Li级程序指令，然后再去取下一条L(i+1)级指令，依此重复进行。
     - 对比：解释执行比执行编译后生成的代码所花的时间多，但占用的存储空间较少。



# 考试内容

**题型**：

**名词解释**，3\*5，每个三分，5个，
**判断题**20个，1.5分*20（重点在第一、二章内容）
**填空**15分 概念和运算
**问答题**40分，有4个（最大的一个为12分）
流水，cache一致性，tomasulo算法

计算题不会很麻烦。

**内容重点：**
3、4、5章是重点！
第8章 多处理器 cache一致性 目录 监听
第4章 tomasulo算法

**说明：**

**本次也没有画图题，不需要拍照**

书上的作业和课后习题好好看一下，实验回顾一下。





# 剩余任务

1.计算题——统一练习一遍

2.实验题

3.各次作业再复习

4.考试题一起做一遍

# 押题

1. tomasulo部分可能是考课上的指令执行后的状态，此时应该是什么？



如何设计？

在Amdahl的传统定义中，计算机系统结构所包含的属性是指机器语言程序设计员为使其设计的程序能在计算机上正确运行所需遵循的计算机属性。而对于通用寄存器型计算机来说，这些属性主要是指：指令系统、中断系统、机器工作状态的定义和切换、存储系统、I/O结构。我们从以上角度入手考虑。

**简述 Tomasulo 算法的基本思想。**

答：**核心思想**是：① **记录和检测指令相关**，**操作数**一旦就绪就立即执行，把发生写后读冲突的可能性减小到最少；② 通过**寄存器换名**来消除读后写冲突和写后写冲突。寄存器换名是通过**保留站**来实现，它保存等待流出和正在流出指令所需要的操作数。

**基本思想**：只要操作数有效，就将其取到保留站，避免指令流出时才到寄存器中取数据，这就使得即将执行的指令从相应的保留站中取得操作数，而不是从寄存器中。指令的执行结果也是直接送到等待数据的其它保留站中去。

因而，对于连续的寄存器写，只有最后一个才真正更新寄存器中的内容。一条指令流出时，存放操作数的寄存器名被换成为对应于该寄存器保留站的名称。











