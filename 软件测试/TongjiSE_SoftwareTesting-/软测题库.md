* fault-error-failure
  * error:”误差“，计算，观察与真实值有偏差。不是所有error都会引起fault
  * Failure：不满足用户需求，系统实际结果和预期结果不符
  * Fault：可以理解为defect。defect是error的表现（如某个浮点数误差算错了可能会让某个计算模块表现与预期表现不符）可能会导致软件组件或系统无法执行其定义的 功能的瑕疵，例如：错误的语句或变量定义。 如果在组件或系统运行中遇到缺陷，可能会导致运行的失败。
  * incident：需要调查的事件
  * problem：出现的问题
* test suite: 一组测试用例可以组成对一个组件/系统的测试集。一般来说，一个测试用例的输出是下个测试用例的输入
  * 例如，测试购买功能，我们就有Login-添加购物车-付钱-logout的一组测试用例。这组测试用例就是对这个系统的test suite
* 缺陷的可扩展性：随着系统的扩大，一个缺陷可能会影响到多个组件与模块。
  * 一个错误的api被多个系统引用，引用的越多缺陷影响越大
* test risk：测试风险，指的是在测试中可能出现或者潜在的问题，典型部分包括测试计划不充分，测试方法有误以及测试过程偏离
  * 计划部分的风险包括测试进度滞后或出现意外事件（天灾人祸）导致无法按时交付测试结果
  * 需求存在风险：用户突然改大需求
  * 缺陷风险：有的缺陷极难复现导致测试难度高，消耗资源多；有的缺陷没有及时上报导致错漏
  * 测试环境风险：测试环境和实际环境有区别
  * 测试技术风险：写测试的人技术不行，工具本身就存在缺陷
  * 研发流程风险
  * 代码质量风险：代码本身就写的一般，架构混乱
* 测试环境：执行测试需要的环境，包括软件环境，硬件环境，数据环境
* 白盒，黑盒，灰盒：白盒是知道要测的代码，根据代码结构设计测试用例；黑盒是不知道要测的代码，根据输入输出设置测试用例；灰盒测试是白盒测试时添加黑盒测试方法，黑盒测试时添加白盒测试的方法，交叉着来
  * 虽然在课本上结构性测试等同于白盒测试，但是一般来说结构性测试是广义方面的白盒测试，它包含白盒测试。结构性测试主要强调根据代码路径（if，while）进行测试，而白盒需要开发人员理解代码细节进行测试。
    * 对于白盒，有域测试（domain testing）。这是基于分析程序的输入空间来检查对于每个输入是否有一个预期的输出。
      * 本质是一个划分空间，首先你需要先将它抽象成数学输入，然后根据谓词（就是if的判断条件）在一个高维空间（取决你有几个变量可以输入）里将这个空间分成不同的区域，然后域内取边界和与边界相邻的点进行测试，有点像等价类+边界值
  * 结构性测试
    * 语句覆盖：设计若干个测试用例，使得程序中每个可执行的语句至少执行一次
      * 有的程序里if没有else，导致其实只覆盖几个分支
    * 判断覆盖：设计若干个测试用例，使得程序中每个判断分支的真和假都执行一次
    * 条件覆盖：需要每个if语句里的每个条件的真假取值至少满足一次
      * 覆盖条件不一定覆盖判断，比如对于一个or前真后假+前假后真走的是同一条路径
    * 判断-条件覆盖：覆盖每个if语句的真假分支程序至少一次+每个条件的真假至少一次
      * 缺点是存在短路运算导致可能if语句里的某些条件其实没有运行到
    * 条件组合覆盖：每个if内的条件组合测试（最强）
* 软件测试的四个阶段：单元测试，集成测试，系统测试，验收测试
  * 单元测试主要是面向当前实现的code的。我们根据详细设计规约进行分析，因为它说明了该函数或模块的输入输出以及算法。用黑盒和白盒设计
  * 集成测试主要是根据接口（API）的设计，即根据概要设计规约的设计来集成。概要设计分解了不同模块，并说明了数据在每个模块之间是怎么流动的，而集成测试就是将不同的模块组装起来。通常用灰盒进行交替测试
  * 系统测试面向需求分析规约进行设计，根据需求分析规约写明的需求流程进行测试，使用黑盒测试检查需求分析规约中的流程是否正确
  * 验收测试面向用例规约，检查客户需求是否正确
* 对于每个测试计划，都有明确的测试过程阶段划分（test process）
  * 软件测试计划阶段：它和开发活动同步进行：需求分析就要完成验收计划；需求分析就完成系统测试计划；概要设计时就完成集成测试计划；详细设计规约时就完成单元测试计划
    * 明确测试任务和测试方法
  * 测试分析和设计：设计一套测试用例，同时选择好的测试人员和组织。
    * 需要确认谁来测，测试环境是什么，测试对象是什么，测试用例怎么设计（用黑盒还是白盒，用等价类还是正交法）
  * 测试实施，执行和监控：了解问题，发现问题，核实问题，评估影响，解决问题
  * 测试报告：起草测试报告，一是检测缺陷数量是否收敛，二是描述测试，这时候要写测试计划文档，测试方案文档，测试用例文档，测试报告文档
  * 测试结束：总结测试过程中收获的教训和经验，并在未来的项目或新一轮测试中使用
* 正负测试
  * negative testing：检查软件如果遇到错误输入它会不会正确地报错，比如我输入错误的密码它能不能拒绝我登录
  * positive testing：检查软件遇到正确输入能不能正确返回结果
* 集成方法
  * bigbang法：非增量式，直接把所有单元测试的模块按照概要设计全组装起来统一测试。
    * 简单，测试用例数目少
    * 但是很难找到真的bug，可能修一个bug出三个bug；同时测试容易不具体
  * 自顶向下集成：从主要模块开始往下测试。对于还没集成的部分我们使用桩函数来代替
    * 缺点是要写桩函数
    * 优点是可以较早的验证完整的软件功能
  * 自底向上集成：从小模块集成，一步一步向上集成
    * 不需要写桩函数，但是需要配置相关驱动模块来模拟输入输出
  * 三明治集成：先选择一层作为中间层，该层以下的自底向上集成，该层向上的自顶而下集成
  * 基于调用图集成
    * 成对集成：我们将桩函数/驱动器换成实际的代码进行集成，一对一对的父子模块地集成
    * 相邻集成：某一个节点的子节点和父节点一起集成，类似于三明治但是上面的驱动和下面的桩函数都用实际的代码进行集成
      * 注意，找到某个节点的缺陷后，该节点和父子节点都要重新测一遍
    * 路径测试：我们可以将每个模块中的几个子节点抽出来，对这个路径进行测试
  * 主干集成测试，类似于自顶向下的集成测试，我们会首先有一个稳定的主干，然后一步一步在它身上添加相关模块。
* 静态测试：人来看以及用静态分析工具来看**（静态就是看，动态就是黑盒白盒）**
  * 人更灵活，能够发挥人自己的逻辑思维来检查；测试工具更完善
  * 流程包括了plan，kick-off，individual preparation，review meeting，rework，follow up
    * plan：首先你得确保你的文档和代码能review，文档没写完/代码编译不了就不谈review
    * kick-off：让所有人理解要review什么，包括介绍项目background和介绍checklist
    * individual preparation：先自己review一遍看看有什么问题，检查和文档是否有冲突/根据自己经验来说有没有问题
    * review meeting：每个人将自己的问题说出来进行讨论，看看有没有更多的问题
    * rework：问题汇总，完善文档和代码
    * Follow up：将已有的缺陷加入监控
  * review 类型
    * walkthrough：走查（比如查代码），不正式
      * 这个就是专门用来检查代码对不对的。人来看一遍代码颅内编译，
    * inspection：调查（根据checklist查缺陷），正式
    * technical review：技术分享，检查代码是不是和文档相互对应
    * informal review：普通的review，在正式review之外进行review，一般在正式review之前先自己看一遍
  * 常用的代码分析工具
    * checkstyle
    * findbugs
    * Jtest
  * 可以查出的问题
    * 有没有死代码，控制流是否存在异常（and or不分），有没有变量未声明就用、未赋值就用，接口描述和实际代码描述是否一致
    * 
* debug和testing：debug是知道有bug了，找到bug根源，然后分析去处；testing是测试有没有bug
* test effort:测试工作量。测试越多代码越完善，但不是说测试越多越好，比如完全测试需要几百万个测试用例。一般来说，测试工作量是开发工作量的1.2倍
* 基准测试：为了让系统或者组件能够进行度量或者比较，制定一套标准
* 探索性测试（explore testing）：由于缺少文档或者缺少时间，测试人员通过自己的直觉或者经验设计几个测试用例来找到自己要测什么，从而完善测试用例设计
* performance testing和 Load testing（压力测试）：performance是一点一点往上加压力检查性能怎么样，load testing是找到系统承受的最大压力
* 基于经验的测试：根据直觉和经验设计测试用例，包括往常出现的错误带来的经验设计
* 等价类
  * 弱一般：等价集个数最多的那一类的个数，其他类均匀覆盖即可
  * 强一般：每个等价类集合进行笛卡尔积（2x4）
  * 弱健壮：弱一般+额外弱健壮：额外弱健壮基于单缺陷，选择某个类的无效类，其他类都是等效类，以此方式测试所有无效类
  * 强健壮：强一般+额外强健壮：基于多缺陷假设，选一个有错的其他没错+选两个有错的其他没错+选三个无效类……全都是无效类
  * 输入/输出的划分（等价类划分方式）：哪个简单选哪个。如果输入规定了范围就可以划分一个有效两个无效，如果输出种类少（比如三角形一题你考虑x=y，x+y>=<z三种输入，但输出等价类只有等边，等腰，非规则，不能组成三角形几类）
* 决策表
  * 条件桩，行动桩：条件桩列出了问题中所有的条件判断；行动桩列出了这个问题中所有的可能执行的范围
    * 例如if(a,b,c)do...else...,那么条件桩有三个（a,b,c),行动桩有两个(do...,else...);
    * 条件数目和行动数目都八个（a，b，c分别T和F的组合）
    * 不关心条目：无论真假都是一个行动/根本不会出现
    * 有限决策表和扩展决策表：有限决策表只考虑每个条件的T和F，而扩展决策表考虑每个条件的取值是多少到多少
* 边界法：最大，最小，大于最大，小于最小，中间
  * 最坏情况是5的n次方个测试用例
* 场景法
  * 逻辑测试用例，物理测试用例：逻辑测试用例是描述了在某个场景下哪些因素符合要求哪些因素不符合要求，根据这个内容来确认走哪一部分的流程，物理测试用例是实际上填的数
    * 例如，付钱的时候，逻辑测试用例是“钱不足，钱足够”，而物理测试用例就是对于1000块的商品付款了500或者1500块
  * 设计方法：先根据需求设定相关场景，然后根据场景设计逻辑测试用例，最后根据逻辑测试用例设计物理测试用例
* 测试优先级
  * 测试优先级描述了每个测试用例的重要性，分别为：出错系统崩溃的测试，出错系统会出现大错误的测试，错误输入的健壮性测试，一些性能，压力等不常执行的测试
* 回归测试：
  * 每次修改/组装新的模块/修改配置等操作时，就需要重新运行所有测试用例或者其中一部分测试用例来检查（尤其是集成测试，因为它的工作量会很大）。
  * 此外，回归测试时不仅要测试原来的测试用例，也应该根据新组装的相关代码设计新的测试用例
* 测试对象，场景，条件：
  * 测试条件也可以描述为需要满足的requirement，即对于一组条件，这个软件应该是报错还是正确执行。（类似于决策表那种四个条件TF组合）
  * 测试对象就是你要测试的东西，可以是一个模块，一个函数，一个子系统等
  * 测试场景就是你的代码在指定的环节下进行运行，一个非常好的例子就是test suite，你的代码需要在一组测试用例中正确运行，这些测试用例设定好了程序的上下文内容（比如用户登录没有）
* 维护性测试，描述了代码在后续运维过程能不能非常好的被修改与维护
  * 分析性：代码是不是够明确？有没有足够的注释？
  * 修改性：代码有没有高内聚低耦合？会不会改一个函数整个代码全要改
  * 稳定性：代码修改会不会很容易引入错误
  * 测试性：代码有没有方便的测试脚手架
  * 适应性：代码兼容性如何
* 容量测试：类似压力测试，检查在需求中指定的最大容量下能不能正确运行代码
* review中的角色描述
  * manager：甲方，项目经理，选择要review的人和东西
  * moderator：对某个review负责，计划执行全review过程，需要记录整理汇报的defect和review过程的内容（data，会议内容）
  * author：被review的东西（文档，代码）的作者
  * reviewer：检查文档的人
  * recorder：汇总本次review结果文档的人
  * two person review：结对编程的副产物。相互检查对方的程序和产物
* 验收测试
  * dogfood测试：开发人员自己写完自己测；
  * alpha测试：公司内部员工自己组织测；
  * beta测试：甲方/应用目标用户测试并且汇报自己的意见（类似于游戏的公测）；
    * 还有用户验收测试，系统管理员的验收测试、基于合同的验收测试
  * 文档测试
    * 需求4份规约，测试计划报告
    * **最重要的是程序维护手册和程序员开发手册**
  * 测试过程：
    * 首先确认验收测试要满足到什么地步，我们会依据需求规约检查是否满足用户的需求
    * 然后检查软件配置全面，包括源程序代码，编译打包脚本，测试程序集，打包好的程序产品以及检查开发、管理文档是否备好
    * 然后检查可执行程序是不是真的符合要求，检查安装、启动、功能、性能等功能是不是稳定
* 正交实验法
  * 总共有多少个被测元素：因素（factor）
    * 在课程项目中，有四个因素
  * 每个元素有多少种取值：水平（因子，level）
    * 课程项目中，有三个因子（三种输入）
  * 测试用例个数：（最大水平数-1）*因素+1
* 鲁棒性测试
  * 一方面是能够经受的住异常的输入输出
  * 另一方面是遇到错误能够快速恢复。
* test harness:测试工具框架/脚手架，包括你的数据，你的脚本and驱动，你的测试结果记录，你的模拟器/桩子
* 基路径
  * 首先画出控制流图，然后计算V（G）=E-n+2，因此基路径至少为V（G）条
  * 然后我们要找到这四条。这四条要求互相独立（即相互不能表示），同时尽量的长
    * 尽可能走出度大于等于2的边，找到最长的那一条基路径，然后从下往上（从上往下也行）对每个出度大于2的节点进行翻转
* validation和verification：validation是指确认，确认产品满足系统需求；verification是指验证，验证是不是和需求一致、和前一段工作一致

## Testing Tools

* 目的：提高测试效率，实现一些人力做不了的测试（压力测试），提高测试准确率
* 类型：有单元、集成、系统的，有性能，安全的，有静态，动态的

## PPT 总结

1. 软件测试是个大工程，占整个开发过程的50%-60%
2. 基础概念
   - 软件测试的目的是检查是否满足需求，因为find defects就能reduce risk
   - debug是localizing+correcting，test是detect
   - **测试包括了test date,plan,test case,object,condition,scenarios(环境,test suite),比较实际输出和期望输出**
   - 使用mean time between failures来描述系统稳定性
   - 无法完全测试：20次循环，每个循环有5种执行分支
   - 测试流程
      * plan：plan需要经常检查，更新，根据进度修改。它包括对资源，任务，组织成员结构，测试管理与设计，**testware（这包括脚本和文档）**，财产，risk估计，退出条件，测试工具，测试框架等（test harness）
      * Design：首先需要分析需求。需求本身应该足够清晰可以正确设计测试用例。我们需要根据需求确定测试的前置条件，预期行为和测试目标的体系结构（确定怎么测它）
        * 然后我们需要分析测试策略，决定我们用什么去测它。我们要确保需求和test本身可以追踪
        * 最后我们设计测试用例，先设计逻辑测试用例，然后根据根据逻辑测试用例再设计物理测试用例（当然，如果需求文档不明确的话可以先找点物理测试用例再反推逻辑测试用例）
        * 注意，我们要确认预期结果，包括函数输出，全局变量（状态变化）以及其他相关变化（test oracle，一组预期结果和实际结果的比较结果，需求就可以当成这个东西）
      * implementation + execution
        * implementation:在这一阶段，我们要把上一阶段搞出来的逻辑测试用例转换成物理测试用例、设置测试环境并运行+记录测试结果（根据测试优先级考虑哪些要执行哪些不执行）、将一组test cases组合成test suites
          * 此外，我们要搭建好测试脚手架（harness），设置好driver，stubs，simulators等
          * 总的来说就是搭建好环境，搞好脚本，把测试用例都组装好，准备点击测试了
        * execution：开始运行测试。测试过程必须完全logged并清晰地记录log：哪部分测试是哪部分模块正在测试的结果，什么时候测的，测的怎么样，测试结果如何
          * 执行的时候也可以大致推测错误是由哪里导致的，有些时候可能就是测试用例写错了和需求对不上，或者你执行错了，或者你环境搭建的有问题
        * Evaluation+report：
          * 首先检查测试结果是否符合退出条件，比如测试用例通过比率由多少，以及代码有没有dead code，比如在一段时间（10周里）每小时报几个错
          * 在测试中找到错误就要修复，然后设计新的test重新测试
        * Closure：记录测试的经验，测试的数据，进行复盘、讨论，用以改进未来的测试
   - 测试principal： 1. 测试是找defects的，2.不可能穷尽测试，3. 测试越早越好，4.缺陷应该收敛，5.杀虫剂悖论：某个测试用例使用越久，它的测试效果会越差。因此旧的测试用例要丢掉新的要加进来 6. 测试基于上下文，不同系统不同需求要有不同测试用例 7.测试没发现failure并不代表系统有用，它对，但是它不一定满足需求
3. 测试周期
   1. V模型：单元测试基于代码开发和组件设计（详细测试规约和概要测试规约），集成测试基于组件设计和体系结构设计哪两个组件拼在一起（概要设计规约和需求分析规约），系统测试基于体系结构和用户需求（需求规约和需求分析规约），验收测试基于用户需求
   2. 名词说明
      1. 单元测试：
         1. test object：一般是代码某个模块、单元后者某个类，或者数据库脚本，或者其他组件。在component testing中我们需要将这个模块隔离出来单独测
         2. test enviroment：提供测试环境，包括部分driver和stubs，driver是用来使用函数的，比如call 某个 a_func()来运行这个函数，提供输入并记录输出（包括调用函数，获取ret，将ret与预期部分进行assert）
         3. maintainability:考察代码结构，高内聚低耦合，注释，是否符合指定规范，代码是否清晰易懂，文档是否准确.
      2. 集成测试
         1. object：几个unit合在一起，考察他们接口之间数据流动是否正确，同时也需要考虑configuration programs是否能正确设置
         2. environment：这时会需要monitors：用来记录data在不同组件之间流动的日志。如果需求中对于某几个组件之间的非功能需求要求很高的话也需要做非功能测试
         3. strategy：最简单是ad hoc strategy（临时安装）：一个component一旦测完了就把它装上已经测好的模块检查对不对，其他的包括topdown，bottomup，adhoc，backbone，bigbang
      3. 系统测试
         1. 检查功能性和非功能性需求
      4. 验收测试
         1. 这里有基于合同的验收测试（是否完成相关需求），用户验收测试（用户用的舒不舒服），field test（面向大市场，需要找一批典型的人来测一测。alpha是公司内测，beta是找一批消费者测，dogfood是一种新的alpha测试，开发完自己用），管理员验收测试（包括容灾，用户管理，系统安全性等）
      5. software maintenance：
         1. 这个东西包括兼容性，能不能快速升级，外部接口和database的使用升级，系统能不能快速恢复
   3. 几种测试
      1. functional测试：检查输入输出的，目的是看适配，正确性，跨平台和安全性，主要是黑盒
      2. nonfunctional 测试：load：人数增量；performance：在不同人数下系统运行的怎么样；volume test：检查系统在大量数据传输下运行的怎么样；stress test：检查系统在高负荷情况允许；security：检查系统能不能守住数据以及验证；stability：检查系统稳定性（多久故障一次）；robustness test；一方面检查系统对错误的硬件，错误的操作的容忍性能不能报错，另一方面检查能不能快速恢复处理错误情况；兼容性（包括数据导入导出，不同操作系统）；configuration testing：不同语言，等能不能正确配置；usability：用的舒不舒服；document；maintainability：文档，代码可读性，注释等
   4. 回归测试：修改程序后再测一次，每个层级都可以测
      1. 有以下几种测法：全测，之前哪个用例出错了测哪里，哪个模块被改动就测哪里，哪个模块是新集成的测哪里
      2. 主要考虑时间和risk
4. static test
   - 尽早开始，但是要等你测的东西完成了再开始，代码至少编译通过，文档至少写完了
   - review，inspection（非常正式的review），peer review（结对编程）
   - 好处：尽早找到defect减少test代价，进而减少failure；缺点是队友狂喷人导致心里负担。因此需要注意review过程对事不对人
   - 过程：
      1. planing：确认review的东西可review，有review 的会议室
      2. kick-off：：确认review范围
      3. individual preparation：自己先看一遍
      4. review meeting：分享自己的意见
      5. rework：谁的工作出问题了谁负责
      6. follow-up：记录跟进管理defect
   - 成员
      1. manager：甲方，本身不参与meeting，只是确认你要review的东西
      2. moderator：review 组组长，管理review 进程，包括plan，preparation，execution，rework，follow up等都要盯着。moderator需要对review会议负责，记录相关数据
      3. author：被review 的文档的负责人
      4. reviewers：参会的其他人（一般最多五个），负责检查文档
      5. recorder：书记员，记录整个参会过程
   - review 类型：
      1. walkthrough：人脑编译指定代码，不正式，就看看你的代码写的有没有错
      2. inspection：非常正式的review，需要有一个checklist来检查
      3. technical review：检查文档是否符合需求，是否规范，和inspection很像
      4. informal review：在inspection前先开个会简单过一遍
      5. two-person-review：互相检查对方的文档代码是否正确，在结对编程时候用
   - 测试工具能干的事
      1. 在实践中只有代码能测
      2. 能测的包括：变量冲突重名，不规范的代码，控制流异常，数据流异常
         1. 本身compiler也是一种静态测试工具，可以测死代码，数组溢出，未声明就使用的变量等
         2. data anomalies：比如变量未赋值就使用，错误包括：
            1. ur：未赋值-使用
            2. du：赋值了，但是赋的值本身是invalid的
            3. dd：某个变量连着赋值两次，导致第一个赋值本身成为死代码了
         3. control flow anomalies：检查if，while和顺序执行的代码是否有错误
            1. 比较典型的就是一个while里多个出口，可能在复杂的循环里跳到错误的地方
            2. 我们用图复杂度检查路径复杂度：e-n+2p，p通常为1因为我们通常只检查一个流。因此复杂度是边数量-点数量+2
               1. 我们不接受复杂度超过10的程序
            3. 当然，你可以把每一条路径都测一遍，但是太久了。我们用基路径测试，后面会提到
5. 动态测试
   - 要说明的包括黑盒测试，白盒测试和基于经验的测试
   - 白盒测试，又叫做structural testing，检查控制流，数据流，组件层级；黑盒测试又叫做functional（specification based，behavioral） testing，基于input-output行为进行测试。两个加在一起是灰盒测试；基于直觉/经验进行的测试一般是黑盒测试，并不是系统测试的方法、
   - 黑盒-等价类（任何时候都能用）；黑盒-边界法：看中文书
      1. 等价类的覆盖率：十八个等价类，但只有十五个被覆盖到，覆盖率就是15/18
      2. 边界值的覆盖率：十五个边界值被测试了/十八个边界值
      3. 边界值的测试依据：对于输入/输出的定义域的边界进行分析
      4. 等价类的测试依据：基于划分的等价类进行分析
   - state transition testing：
      1. 基于state diagram和state transition table来记录该程序的行为
      2. 测试要求：至少覆盖所有状态一次；至少覆盖所有function一次；因此需要transition tree去检查
         1. transition tree:对于每个状态，下一个可能的状态作为它的子节点
         2. 遍历transition tree的所有节点
         3. 这样一定能覆盖所有function+所有节点一次
      3. 这个transition testing也对GUI的测试有很大的好处
   - 因果图法（cause-effect graph):如果做了某个行为（或没做某个行为），或者做了什么and什么或者做了什么or什么就会导致另一个行为
      1. 取钱：插入合法卡就是进入界面，插入非法卡就是拒绝界面；输入密码或者输入指纹进入取钱界面；输入金额and输入密码获得钱
      2. 进一步：我们就到决策表了。
      3. 退出标准：每一个行为都执行一次
   - use case法（场景法）：每个use case至少执行一次
      1. 基本流和备选流：基本流是正常的业务流，备选流是那些非正常的、意外触发的，会中断的业务流
      2. 设计法：根据规约分析出基本流和备选流，然后根据每一条流设计不同的场景，根据场景设计逻辑测试用例，根据逻辑测试用例设计物理测试用例
      3. 要求：对基本流和备选流至少覆盖一次
   - 基于直觉和经验的测试：基于测试者的技巧，经验，知识设计的测试用例
      1. 这也叫error guessing
      2. 首先是exploratory testing，这个测试是文档不全面，甚至只有代码进行的测试，或者时间极度紧张的时候进行的。测试者首先自己设计几个测试用例，然后根据物理测试用例去决定逻辑测试用例
      3. 没有固定的退出要求