---
typora-root-url: C:\Users\ajxfl\Documents\WPS Cloud Files\705827800\A操作系统\OS复习
---

# Part1概述 ch1

## 操作系统定义*

### 定义

操作系统是计算机系统中的一个系统软件，管理和控制计算机系统的软、硬件资源，合理地组织计算机的工作流程，以便有效利用这些资源为用户提供一个功能强、使用方便的工作环境，从而在计算机与用户之间起到接口的作用

### 主要功能模块

进程管理

内存管理

文件管理

设备管理

### 四个观点

#### 用户环境观点

操作系统是计算机用户使用计算机的接口，  为用户提供便捷的工作环境。

#### 虚拟机器观点

操作系统是建立在计算机硬件平台上的虚拟机器，为应用软件提供更强或硬件不能直接提供的功能。

操作系统在虚拟机中充当管理员和协调员，管理软硬件资源，并协调多任务的运行。

实现功能和系统规模的扩充。

#### 资源管理观点

操作系统是计算机中各类资源的管理者，负责分配、回收及控制资源。

跟踪资源的使用状况，提高资源利用率，协调各程序和用户对资源的使用冲突。

#### 作业组织观点

操作系统是计算机工作流程的组织者，负责协调系统中运行的各应用软件的运行次序。

报告执行结果或错误信息。

减少人工干预，提高系统效率和吞吐量。

## 操作系统发展

### 主要发展阶段

(1)人工操作阶段 

(2)单道批处理阶段 

(3)执行系统阶段 

(4)多道程序系统阶段

### 批处理系统

批处理把用户提交的作业成批送入计算机，然后由作业调度程序(长程调度)自动选择作业运行，以缩短作业间的交接时间，减少CPU的空闲等待，从而提高系统效率。代表产品是1964年IBM360机器配置的操作系统OS/360(第一款通用操作系统)。

### 分时系统

分时处理也叫“会话型处理”， 强调用户和系统的**交互性**。

分时技术是将CPU时间划分成小时间片（Time Slicing），用户以时间片为单位轮流使用CPU（时分复用）。

分时处理的特征： 并发性 交互性 独占性 及时性       现在大多数操作系统都是分时操作系统。



## 操作系统特征*

### 特征

- 并发性: 所谓并发，是指两个或两个以上事件在同一时间间隔内发生。

  （并发技术实际上是物理CPU在多道程序之间的多路复用，从而实现程序间的并发，以及CPU和设备、设备和设备间的并行，提高资源利用率。）

- 共享性: 所谓共享是指系统中的硬件和软件资源可为多个用户同时使用。

- 虚拟性: 所谓虚拟是指把物理上的一个实体变成逻辑上的多个对应物。

-  异步性: 所谓异步性是指在多道程序环境下，允许多个进程并发执行，各进程是以不可预知速度推进的。

并发和共享是操作系统的两个最基本特征，它们之间是相辅相成、互为依存条件的。

### 基本类型

#### 多道批处理系统

多道批处理系统实际上是把批量处理技术和多道程序技术相结合的产物.

#### 分时系统

在分时环境下，一个计算机系统连接有若干个本地或远程终端，每个用户都可以在自己的终端上以交互方式使用计算机，对系统资源进行时间上的分享。 

#### 实时系统

实时系统则是指系统对特定输入做出反应的速度足以控制发出实时信号的对象。

#### 通用操作系统

对于批处理系统、分时系统和实时系统，如果一个操作系统同时具有其中两者或两者以上功能，则称这样的操作系统为通用操作系统。

#### 网络操作系统

网络操作系统是使网络上各计算机能方便而有效地共享网络资源，为网络用户提供所需的各种服务的软件和有关规程的集合。

## 操作系统目标*

作为计算机用户和计算机硬件之间的媒介的一种程序。

用户角度---方便使用

系统角度---高效、功能扩展

# Part2 进程管理 ch4 5 6 7 8

## 进程*

### 引入目的

更好的使多道程序并发执行，提高资源利用率和系统吞吐率

### 定义

进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。 

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

### 特征

- 并发性 任何进程都可以同其他进程一起向前推进
- 动态性 进程对应程序的执行，进程是动态产生，动态消亡的；进程在其生命周期内，在三种基本状态之间转换
- 独立性 进程是资源分配的一个独立单位
- 交互性 指进程在执行过程中可能与其它进程产生直接或间接的关系
- 异步性 每个进程都以其相对独立的、不可预知的速度向前推进
- 结构性 进程的组成：程序+数据+PCB

### **进程的三种基本状态**

-  就绪(Ready)状态：当进程已分配到除 CPU 以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。

-  运行（Running）状态：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为运行状态。

- 等待(Waiting)状态：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于等待状态。

  ![进程状态转移](/../../../../../../../../进程状态转移.jpg)

### **进程的组成**

- 进程控制块 PCB：每一个进程均有一个进程控制块 PCB。用户进程被创建时，系统为它申请和构造一个相应的 PCB。
- 程序段：程序段是进程中能被进程调度程序调度在 CPU 上执行的程序代码段，它能实现相应的特定功能。 
- 数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果数据

### **进程控制块**作用

PCB 通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。

系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程等。    

系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的**唯一标志**。进程与PCB是一一对应的。

### PCB表

系统把所有PCB组织在一起，并放在内存固定区域，就构成了PCB表。

PCB表的大小决定了系统中最多可同时存在的进程个数，称为系统的并发度

## 线程

### 引入目的

减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能

没引入线程之前，进程的两个基本特性：资源分配的独立单位调度的基本单位

引入线程概念，将进程资源分配和任务调度分开。

**进程是资源分配的独立单位**

**线程是调度的基本单位**

### 引入益处

#### 开销

启动一个新进程必须分配独立地址空间，建立众多的数据表来维护它的代码段、堆栈段，这是一种很“昂贵”的多任务工作方式 。

运行于一个进程中的多个线程，彼此之间使用相同的地址空间，共享大部分代码和数据（包括堆区），启动一个线程所花费的空间远远小于启动一个进程所花费的空间。

线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。

#### 通信

不同进程具有独立的数据空间，要进行数据的传递只能通过通信方式进行，这种方式不仅费时，而且很不方便。

由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。

#### 总结

- 创建一个新线程花费时间和资源少，响应度高
- 两个线程的切换花费时间少
- 同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核
- 适合多处理机系统（实现真正意义上的并行）

### 定义

进程的执行体、一个执行单元、进程内的一个可调度实体等。

线程---轻量级进程

- 进程中的一个运行实体
- 是一个CPU调度单位
- 资源的拥有者是进程，线程不能独立存在
- 可由内核控制，也可由用户控制

**基本的CPU执行单元**

**程序执行流的最小单元**

### 线程组成

基本上不拥有系统资源，存取所在进程的内存和其他资源

只包含一些如程序计数器、寄存器和一组栈

TCB（线程控制块）

不运行时保存上下文

## 进程调度

### 调度类型

#### 高级调度（长程调度）

也称为作业调度或宏观调度，高级调度的时间尺度通常是分钟、小时或天。--- 形成作业队列

#### 中级调度（中程调度）      

涉及进程在内外存间的交换。从存储器资源管理的角度来看，把进程部分或全部换出到外存上，可为当前运行进程的执行提供所需内存空间，将当前进程所需部分换入到内存。指令和数据必须在内存里才能被处理机直接访问。

#### 低级调度（短程调度）      

也称微观调度，从处理机资源分配的角度来看，处理机需要经常选择就绪进程或线程进入运行状态。低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效。

## CPU调度

### 基本概念

#### 调度目的

最大化CPU利用率

### 调度算法

#### FCFS 先到先行调度

在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到运行完成或因某种原因而阻塞时才释放处理机

算法简单，但效率低

对长作业比较有利，但对短作业不利

有利于CPU繁忙型作业，不利于I/O繁忙型作业

#### SJF 最短作业优先调度

缺点：

- 对长作业不利，将导致长作业长期不被调度
- 完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理
- 作业的长短难以估计

SJF的平均等待时间、平均周转时间最少

#### Priority Scheduling 优先级调度

在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。

在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行

#### RR 时间片轮转调度

主要适用于分时系统

#### Multilevel Queue 多级队列调度

### 原语

#### 定义

是操作系统中内核中由若干条指令构成，用于完成特定功能的一个过程，该过程在执行时是不可中断的

## 临界区

### 临界资源

系统中某些资源一次只允许一个进程使用，这样的资源为临界资源或互斥资源

### 临界区（互斥区）

在进程中涉及到临界资源的程序段叫临界区。

### 同步机制原则

**互斥访问**

**空闲让进** 

忙则等待

多中择一

**有限等待**

**让权等待** 

### 实现临界区互斥的方法

#### 软件

##### 算法1：单标志位

设有两个进程Pi, Pj，其中Pi进程设立一个公用整型变量 turn，用来描述允许进入临界区的进程标识。

- 在进入区循环检查是否允许本进程进入

- turn为i时，进程Pi可进入

- 在退出区修改允许进入进程标识

- 进程Pi退出时，改turn为进程Pj的标识j；

  ![image-20230620152917097](/../../../../../../../../image-20230620152917097-16872461590077.png)

**缺点**：进程强制轮流进入临界区，容易造成资源利用不充分。如：在Pi让出临界区之后，Pj使用临界区之前，Pi不可能再次使用临界区。

##### 算法2：双标志法（先检查）

设立一个标志数组flag[]：描述进程是否在临界区，初值均为FALSE（未使用）。如flag[i]=FALSE   //Pi未进入临界区。

- 先检查，后修改  

  在进入区检查另一个进程是否在临界区，不在时修改本进程在临界区的标志；

- 在退出区修改本进程在临界区的标志；

  ![image-20230620152901240](/../../../../../../../../image-20230620152901240-16872461431785.png)

**优点**  不用交替进入，可连续使用

**缺点**   Pi和Pj可能同时进入临界区

eg:

“Pi<a> Pj<a> Pi<b> Pj<b>”。即在检查对方flag之后和切换自己flag之前有一段时间，结果都检查通过。

##### 算法3：双标志法（先修改）

先修改后检查

![image-20230620152824645](/../../../../../../../../image-20230620152824645-16872461068273.png)

**优点**   防止两个进程同时进入临界区

**缺点**  Pi和Pj可能都进入不了临界区

eg:

按下面序列执行时，都进不了临界区：“Pi<b> Pj<b> Pi<a> Pj<a>”。即在切换自己flag之后和检查对方flag之前有一段时间，结果都切换flag，都检查不通过。

算法2,3问题出在：检查和修改操作不能连续进行

##### 算法4：

正确的算法  先修改、后检查、后修改者等待

- turn=j;描述可进入的进程（同时修改标志位）

- 在进入区先修改后检查，并检查并发修改的先后

  - 检查对方flag，如果不在临界区则自己进入

    ​		－－空闲则入

  - 再检查turn：保存的是较晚的一次赋值，则较晚的进程等待，较早的进程进入 

    ​		－－先到先入，后到等待

    ![image-20230620152732308](/../../../../../../../../image-20230620152732308-16872460630511.png)

##### 软件算法的缺点

忙等待(做不到让权等待)

实现过于复杂，需要高的编程技巧

#### 硬件

Test_and_set“测试并设置”指令

Compare_and_swap“交换”指令

“开关中断”指令

##### 硬件方法优点

- 适用于任意数目的进程，在单处理器或多处理器上均适用
- 简单，容易验证其正确性
- 可以支持进程内存的多个临界区，只需为每个临界区设立一个布尔变量

##### 硬件方法缺点

- 等待要耗费CPU时间，不能实现“让权等待”
- 可能“饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上
- 可能死锁
- 用户程序一般不能直接使用 

## 进程同步

### 定义

所谓进程同步是指多个合作进程为了完成同一个任务，它们在执行速度上必须相互协调

### 同步机制

OS可从进程管理者的角度来处理互斥同步问题，这就是同步机制。

信号量P、V操作；管程（资源管理模块）；条件临界域等

### 信号量

#### 定义

信号量表示资源的实体，是一个与队列有关的整型变量。

信号量只能通过初始化和P/V原语来访问，不受进程调度的打断。

#### 物理含义

- S>0 表示有S个资源可用   
-  S=0 表示无资源可用    
- S<0 则|S|表示S等待队列中的进程个数

#### 类型

- 互斥信号量用于申请或释放资源的使用权，常初始化为1。 
- 资源信号量用于申请或归还资源，可以初始化为大于1的正整数，表示系统中   某类资源的可用数。

### P/V操作*

#### P原语（wait）

```c
wait(semaphore *S) { 
   S->value--; 
   if (S->value < 0) {
   	  add this process to S->list; 
      block(); 
   } 
}
```

P操作用于申请资源（或使用权），进程执行P原语时，可能阻塞自己；

执行P操作意味着申请分配一个单位的资源

![image-20230620154106994](/../../../../../../../../image-20230620154106994-16872468705009.png)

#### V原语（signal）

```c
signal(semaphore *S) { 
   S->value++; 
   if (S->value <= 0) {  
   	  remove a process P from S->list; 
      wakeup(P); 
   } 
} 
```

V操作用于释放资源（或使用权），执行V原语时可能需要唤醒一个阻塞进程。

执行V操作意味着释放一个单位的资源

![image-20230620154529808](/../../../../../../../../image-20230620154529808-168724713277911.png)

#### PV操作必须成对出现

- 当为互斥操作时，它们同处于同一进程
- 当为同步操作时，则在不同进程中出现      

​		如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要。

#### P/V优缺点

- 简单，而且表达能力强 
- 不够安全，使用不当会出现死锁；
- 遇到复杂同步互斥问题时实现复杂

### 典型同步互斥问题

#### 生产者－消费者问题

必须使生产者和消费者互斥进缓冲区，即某一时刻只允许一个实体（生产者或消费者）访问缓冲区。

生产者不能向满缓冲区放数据，消费者也不能在空缓冲区中取数据，两者必须同步

##### 问题解决

- full是“满”数目，初值为0，empty是“空”数目，初值为N。实际上，full和empty是同一个含义：full + empty == N
- mutex用于访问缓冲区时的互斥，初值是1
- 每个进程中各个P操作的次序是重要的：先检查资源数目，再检查是否互斥――否则可能死锁

![image-20230620160242220](/../../../../../../../../image-20230620160242220.png)

#### 读者－写者问题

##### 第一类：读者优先（重点）

- 无读者、写者可写
- 有写者写，读者等
- 有读者在读，写者等待，但此时新读者可以进行读，写者接着等待
- 最后一个读者完成访问后，发现写者在等，则唤醒其中一个写着。
- 写者完成访问后，发现有等待者，按照FIFO或者其它原则唤醒写者或者所有读者（注意此时并没强调读者优先）
- 读者优先可能导致写者饥饿

![image-20230620160746913](/../../../../../../../../image-20230620160746913.png)

![image-20230620160800620](/../../../../../../../../image-20230620160800620.png)

##### 第二类：写者优先

- 多个读者可以同时进行读
- 写者必须互斥，即只允许一个写者写
- 不能读者写者同时进行，写者优先于读者，即一旦有写者，则后续读者必须等待，唤醒时优先考虑写者

![image-20230620160918771](/../../../../../../../../image-20230620160918771.png)

![image-20230620160931147](/../../../../../../../../image-20230620160931147.png)

#### 总结

- 进程应该先申请资源信号量，再申请互斥信号量，顺序不能颠倒——同步在外，互斥在内；
- 对任何信号量的P/V操作必须成对使用。同一进程中的多对P/V语句只能嵌套，不能交叉；
- 对同一信号量的P/V操作可以不在同一进程中；
- P/V语句不能颠倒顺序。

### 进程互斥

#### 定义

所谓进程互斥是指当有若干进程都要使用某一共享资源时，最多允许一个进程使用，而其他要使用该资源的进程必须等待，直到占用该资源的进程释放了该资源为止。





## 进程通信

### 通信类型

#### 低级通信（定长）

只能传递状态和整数值

传送信息量小：效率低，每次通信传递的信息量固定，若传递较多信息则需要进行多次通信。

编程复杂：用户直接实现通信的细节，编程复杂，容易出错。

#### 高级通信(变长) 

能够传送任意数量的数据，对系统实现要求高，但编程简单

### 通信方式

#### 共享存储

进程共享某些数据结构或者共享存储区，通过这些空间进行通信。

- 基于共享数据结构的通信方式  效率低，适合传递少量数据。
- 基于共享存储区的通信方式  高级通信方式，可传输大量数据。

#### 消息传递

最广泛一种通信机制，适用于多核和分布式系统

系统为进程提供了两个通讯原语：    send()和receive()。

- 直接通信 如消息队列通信方式
- 间接通信 如信箱通信方式

#### 管道通信（共享文件）

基于文件系统，利用一个打开的共享文件连接两个相互通信的进程，文件作为缓冲传输介质。

- 普通管道（匿名管道）  	
  - 每个管道单向通信
  - 只能由创建管道的进程使用，通常使用在父子进程之间的通讯（在子进程继承父进程资源的系统上）
  - 通信结束自动删除
- 命名管道  
  - 支持双向通信（Uuix半双工，Windows支持全双工）
  - 不限制父子进程间，支持多进程通信
  -  要显式删除

#### 网络通信

- 套接字
- 远程过程调用RPC



## 死锁

### 死锁的概念

#### 定义

指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进

#### 产生的原因

- 系统资源的竞争

​			只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的

- 进程推进顺序非法
  - 请求和释放资源的顺序不当
  - 信号量使用不当

#### 死锁产生的必要条件

- 互斥
- 占用并等待
- 非抢占
- 循环等待

### 资源分配图判断死锁

资源分配图不含圈，一定不死锁

资源分配图含圈，不一定死锁

![image-20230620162845310](/../../../../../../../../image-20230620162845310.png)

<img src="/../../../../../../../../image-20230620162923282.png" alt="image-20230620162923282" style="zoom:50%;" />

<img src="/../../../../../../../../image-20230620162933215.png" alt="image-20230620162933215" style="zoom:50%;" />

# Part3 内存管理 ch9 10

## 引言

### 装入步骤

创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要一下步骤：

- 编译 由编译程序将用户源代码编译成若干目标模块
- 链接 由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块
- 装入 由装入程序将装入模块装入内存运行

### 链接

- 静态链接  

  - 程序运行之前，将各目标模块及所需函数，链接成为一个完整的装入模块，以后不再拆开。

- 动态链接

  - 装入时动态链接            

    一组目标模块，在装入内存时，边装入边链接。 

  -  运行时动态链接    

     程序执行中需要该目标模块时，才进行链接。

### 装入

#### 地址再定位技术

- 将逻辑地址和物理内存地址对应起来的过程；
- 地址再定位由操作系统中的装入程序来完成。

#### 绝对装入技术

程序地址再定位在执行之前被确定，也就是在编译链接时直接制定程序在执行时访问的实际存储器地址。

程序地址空间和内存地址空间是一一对应。

优点 装入过程简单 

缺点 过于依赖于硬件结构，不适于多道程序系统

#### 静态再定位（静态映射）

由装入程序在程序执行之前进行地址再定位，地址定位完成后，在程序执行期间不会发生变化。

优点 易实现，无需硬件支持

缺点 

- 程序再定位后就不能移动，因而不能重新分配内存，不利于内存的有效利用。
- 程序在存储空间中只能连续分配，不能分布在内存的不同区域。

#### 动态再定位（动态映射）

程序装入内存时，不修改逻辑地址，在访问物理内存之前，再实时地将逻辑地址转换成物理地址。

优点 

- 程序在执行过程中可以移动，有利于内存充分利用。 
- 程序不必连续存放在内存中，可分散在内存若干个不同区域，只需增加几对基址或界限寄存器，每对寄存器对应一个区域。 

缺点 需要附加硬件支持，实现存储管理的软件算法比较复杂。

## 分区存储管理

分区内存管理机制中的分区分配方法、特点、快表

### 基本原理

把内存分为一些大小相等或不等的分区，每个应用进程占用一个或几个分区。操作系统占用其中一个分区

### 特点

适用于多道程序系统和分时系统 

支持多个程序并发执行

### 问题

可能存在内碎片和外碎片。  

难以进行内存分区的共享。

### 分区表

- 可以只记录空闲分区，也可以同时记录空闲和占用分区
- 分区表可以划分为两个表格：空闲分区表，占用分区表。
- 分区表中，表项数目随着内存的分配和释放而动态改变，可以规定最大表项数目。
- 空闲分区表中按不同分配算法相应对表项排序。

### 固定分区

### 基本思想       

内存划分为若干个固定大小的连续分区

- 分区大小相等
  - 适合于多个相同程序的并发执行（处理多个类型相同的对象）。
- 分区大小不等           
  - 多个小分区、适量的中等分区、少量的大分区。
  - 根据程序的大小，分配当前空闲的、适当大小的分区。

#### 优点

- 比单一连续分配方法，内存利用率提高了
- 可以支持多道程序
- 实现简单

#### 缺点

- 作业必须预先能够估计自己要占用多大的内存空间
- 内碎片造成浪费
- 分区总数固定，限制了并发执行的程序数目。

### 动态分区

#### 基本原理           

在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。 

#### 优点        

没有内碎片

#### 缺点        

有外碎片

### 分区分配算法           

 寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区的先后次序通常是从内存低端到高端。

### 评价

#### 优点

- 实现了主存共享，有助于多道程序设计
- 动态分区主存利用率比固定分区高些
- 相对于后面介绍的存储管理方式，本方案为实现分区分配所使用的表格，占用存储容量相对较少，算法也相对简单。
- 实现存储保护的措施也比较简单。
- 多重分区分配方案能实现对子程序、数据段的共享。

#### 缺点

- 主存仍不能充分利用，除了采用紧凑技术外，都存在着严重碎片。
- 不能实现对主存扩充
- 和单一连续分配一样，要求一个作业执行前必须全部装入主存。

### 常用分区分配算法

#### 最先适配算法 

按分区先后次序，从头查找，找到符合要求的第一个分区。

#### 循环最先适配算法 

按分区先后次序，从上次分配的分区起查找（到最后分区时再回到开头），找到符合要求的第一个分区。

#### 最佳适配算法 

在所有大于或者等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。分配后，所剩余的块会最小。

#### 最坏适配算法

分区时取所有空闲区中最大的一块，把剩余的块再变成一个新的小一点的空闲区。

## 页式存储管理

### 基本原理

#### 用户空间划分

把用户程序按逻辑页划分成大小相等的部分，称为页（虚页）。从0开始编制页号，页内地址是相对于0编址。

 用户空间划分是由系统自动完成的，对用户是透明的。一般，页大小为2的整数次幂，因此，地址的高位部分为页号，低位部分为页内地址

<img src="/../../../../../../../../image-20230620201245502.png" alt="image-20230620201245502" style="zoom:50%;" />

#### 内存空间划分

按页的大小划分为大小相等的区域，称为内存块（物理页面，页框、实页）

#### 内存分配

以页为单位进行分配，并按作业的页数多少来分配。逻辑上相邻的页，物理上不一定相邻。

### 存储管理

#### 进程页表

系统为每个进程建立一个页表，页表给出逻辑页号和具体内存块号相应的关系；   

页表放在内存，属于进程的现场信息。

#### 物理页面表

 整个系统有一个物理页面表，描述物理内存空间的分配使用状况。

#### 请求表

整个系统有一个请求表，描述系统内各个进程页表位置和大小，用于地址转换，也可结合到各进程PCB里；

### 管理过程

- 计算一个作业所需要的总块数N
- 查位示图，看看是否还有N个空闲块
- 如果有足够的空闲块，则页表长度设为N，可填入PCB中；申请页表区，把页表始址填入PCB
- 依次分配N个空闲块，将块号和页号填入页表
- 修改位示图

### 硬件支持

系统设置一对寄存器： 页表始址寄存器 页表长度寄存器

联想寄存器——快表     

为缩短查找时间，可将页表从内存装入到关联存储器(TLB—translation lookaside buffer)，按内容查找，即逻辑页号－>物理页号。

### 评价

#### 优点  

解决了碎片问题  

便于管理

#### 缺点  

不易实现程序共享  

不便于动态链接

## 虚拟存储器

### 特征

#### 不连续性

物理内存分配的不连续;   

虚拟地址空间使用的不连续。

#### 部分交换

与整体交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的

#### 大空间    

通过物理内存和快速外存相结合，提供大范围的虚拟地址空间，总容量不超过物理内存和外存交换区容量

## 请求分页管理方式

### 页表项结构

![image-20230620204905474](/../../../../../../../../image-20230620204905474.png)

中断位：页面存在与否；

保护位：有关页面的读/写控制等;

访问位：表示页面是否正在被使用，用于页表置换；

修改位：表示页面有没有被修改过；

### 中断处理

#### 保护中断 

读/写位和用户/超级用户位等保护位不用于地址转换，用于保护机制

#### 缺页中断

地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，将该页从外存调入内存，使作业继续运行下去

如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的驻留位及相应的内存块号。

如果内存中没有空闲块，则**页面置换**

### 页面置换算法

#### 先进先出算法(FIFO) 

- 选择建立最早的页面被置换。
- 可通过链表来表示各页的建立时间先后。
- 性能较差。
- 较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。

#### 最佳算法（OPT-optimal） 

选择“未来不再使用的”或“在离当前最远位置上出现的”页面被置换。 

这是一种理想情况，实际执行中无法预知未来使用情况，因而不能实现。 可用作性能评价的依据。

#### 最近最久未使用算法(LRU-Least Recently Used) 

选择内存中最久未使用的页面被置换

是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。

#### 最不常用算法(LFU-Least Frequently Used) 

选择到当前时间为止被访问次数最少的页面被置换；

每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；

发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。

#### 轮转算法(clock)

也称最近未使用算法(NRU)，是LRU(最近最久未使用算法)和FIFO的折衷。

每页有一个标志位(use)，若该页被访问则置user =1             

置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找use=0的页面作为被置换页，并将指针经过的页修改为user=0 ，最后指针停留在被置换页的下一个页。

#### 缺页率     

缺页率＝缺页次数/访问总次数。

# Part4 文件管理 ch11

## 文件

 信息以一种逻辑单元，即文件的形式存储在磁盘或其他外部介质上

## 文件系统

负责信息组织、存储和访问，提供高效、快速和方便的信息存储和访问功能。

### 定义

是操作系统中统一管理信息资源的一种软件。

管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用。

### 功能

- 统一管理文件的存储空间，实施存储空间的分配与回收。
- 实现文件的按名存取
- 实现文件信息的共享，并提供文件保护和保密措施
- 向用户提供方便使用的接口
- 系统维护及向用户提供有关信息
- 文件系统的执行效率
- 提供与I/O的统一接口

## 文件定义

一组带标识的、在逻辑上有完整意义的信息项的序列。

## 文件结构

### 逻辑结构

#### 无结构文件（流式文件）

构成文件的基本单位是字符，文件是有逻辑意义的、无结构的一串字符的集合

一个无结构字节序列

好处  提供很大的灵活性

#### 有结构文件（记录式文件）

文件是由若干个记录组成，每个记录有一个键，可按键进行查找,适用快速定位。

 一个固定长度记录的序列，每条记录有其内部结构。

### 物理结构

从系统角度来看文件，从文件在物理介质上的存放方式来研究文件。

#### 连续（顺序）结构 

- 优点
  - 简单 
  - 支持顺序存取和随机存取
  - 顺序存取速度快
  - 所需的磁盘寻道次数和寻道时间最少

- 缺点 
  - 文件不能动态增长 
  - 预留空间:浪费 
  - 不利于文件插入和删除 
  - 外部碎片问题 


##### 链接结构

- 优点
  - 提高了磁盘空间利用率,不存在外部碎片问题
  - 有利于文件插入和删除
  - 有利于文件动态扩充
- 缺点
  - 存取速度慢，不适于随机存取
  - 可靠性问题，如指针出错
  - 更多的寻道次数和寻道时间
  - 链接指针占用一定的空间

##### 索引结构   

- 优点
  - 即能顺序存取,又能随机存取
  - 满足了文件动态增长、插入删除要求
  - 能充分利用外存空间
- 缺点
  - 较多的寻道次数和寻道时间
  - 索引表本身带来了系统开销  

## 目录结构

### 文件控制块（FCB）

- 文件控制块是操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有有关信息（文件属性）
- 文件控制块是文件存在的标志

目录项内容

**基本信息**：文件名、类型、组织等；

**地址信息**：卷(存储文件设备)、起始地址、长度等；

**访问控制信息**：所有者、访问信息(用户名及口令等)、合法操作等；

**使用信息**：创建时间、创建者身份、当前状态、最近修改时间、最近修改时间等。

#### 文件目录  

把所有FCB组织在一起，就构成了文件目录，即文件控制块的有序集合

#### 目录项  

构成文件目录的项目（目录项就是FCB）

#### 目录文件  

为实现对文件目录的管理，通常将文件目录以文件形式保存在外存，这个文件就叫目录文件。

### 多级目录结构--树型目录

系统将当前工作目录中的内容复制到内存缓冲区中，在访问文件时先访问内存中的工作目录。当要访问的文件不在当前目录中时，再访问外存中的目录，提高了查找速度。

优点

- 层次结构清晰，便于管理和保护
- 有利于文件分类
- 解决重名问题
- 提高文件检索速度
- 能进行存取权限的控制 

缺点

- 查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。
- 不利于文件共享

## 文件访问方法

### 目录检索 

用户给出文件名，按名寻找目录项 

根据路径名检索：

### 文件寻址

根据FCB中文件物理地址等信息，求出文件的任意记录或字符在存取介质上的地址，称为文件寻址。 

## 目录结构改进

### 改进方法

采用目录项分解法，把FCB分成两部分。 

- 符号目录顶（次部）   
  - 文件名，文件号 
- 基本目录项（主部）   
  - 除文件名外的所有项目

<img src="/../../../../../../../../image-20230620214350096.png" alt="image-20230620214350096" style="zoom:50%;" />

## 空闲空间管理

### 数据结构

#### 空闲块表

适合建立连续文件

所有空闲块记录在一个表中

#### 空闲块链表

把所有空闲块链成一个链

### 管理方法

#### 位图法

用一串二进制位反映磁盘空间中的分配使用情况, 每个物理块对应一位, 分配物理块为1，否则为0。

- 申请物理块时，在位示图中查找为0的位，返回对应物理块号； 
- 归还时，将对应位转置0 
- 描述能力强，适合各种物理结构

已知块号，则磁盘地址：    

柱面号＝[块号/（磁头数×扇区数）]   

磁头号＝[（块号mod （磁头数×扇区数））/扇区数]   

扇区号＝（块号mod （磁头数×扇区数））mod 扇区数 

已知磁盘地址：    

块号＝柱面号×（磁头数×扇区数）＋磁头号×扇区数＋扇区号

#### 成组链接法

是对空闲块链表进行改进，将空闲块分成若干组，用指针将各组相连，以提高管理效率。

## 磁盘调度算法

### 先来先服务（FCFS）

按访问请求到达的先后次序服务

效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利。

### 最短寻道时间优先（SSTF）

优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。

优点  

改善了磁盘平均服务时间

缺点     

由于访问需求的不断提出，会造成远离中部区域的访问请求长期等待得不到服务。

### 扫描算法（电梯算法）

既考虑了距离，同时又考虑了方向，克服了最短寻道优先的缺点。

- 当设备无访问请求时，磁头不动；
- 当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；
- 否则改变移动方向，并为经过的访问请求服务，如此反复

### 单向扫描调度算法（C_SCAN）

- 总是从0号柱面开始向里扫描；
- 按照各自所要访问的柱面位置的次序去选择访问者；
- 移动臂到达最后个一个柱面后，立即带动读写磁头快速返回到0号柱面；
- 返回时不为任何的等待访问者服务；
- 返回后可再次进行扫描 



# Part5 小知识

1. 操作系统的软件体系结构发展阶段是？

​		单一结构，核心层次结构，微内核结构

2. 强调交互性的操作系统是？

   分时系统

3. 系统中有5个并发进程，如果其都涉及某个共享变量A，则变量A的相关临界区是由（5 ）个临界区构成

4. 在可变分区管理中，若采用最先适应分配算法，通常将空闲区按（ ）排列。

​      地址递增

5. 解决“碎片”问题最好的存储管理方法是页面存储管理

6. 在内存管理中常会用到联想存储器，其用于存放页表信息

7. 位示图方法可用于磁盘空间管理

8. 同步是直接制约关系  互斥是间接制约关系

9. **并发**和**共享**是操作系统的两个最**基本**特征，它们之间是相辅相成、互为依存条件的。